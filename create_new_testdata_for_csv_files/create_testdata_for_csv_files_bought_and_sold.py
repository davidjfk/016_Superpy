import csv, os
from itertools import product
import random
from copy import deepcopy

'''
    Goal: create testdata for bought.csv and sold.csv.

    manual:
        1. running the code will create testdata for bought.csv and sold.csv.
        2. bought.csv and sold.csv are created inside directory create_new_tesdata_for_csv_files.
           Parts of the created data are random, so the testdata will be different each time the code is run.
        3. I have manually copied this data into directory csv_files_used_by_superpy. So this 
           is a frozen copy to be used to create pytest testcases for TDD-software-development.

        4. This script can be run again to create new testdata for bought.csv and sold.csv and be
           used for other purposes.

    design choices for bought.csv: 
        testdata is created for 60 days (day 1 to day 60 inclusive)
        products all expire after 5 days.
        products are bought on random days between day 1 and day 55 inclusive.

    design choices for sold.csv:
        sold.csv is copy of bought.csv, but with following modifications:
            -every 5th product is not sold (so will expire while time traveling)
            -each product is sold for 3 times the price it was bought for.
            -each product is sold 2 days after it was bought (supermarkets have fast stock turnover). 



'''

# part 1 of 2: create testdata for bought.csv

#math highschool analogy: (5+2)*(3+4) == 5*3 + 5*4 + 2*3 + 2*4
products = ['apple', 'banana', 'kiwi', 'beans', 'quinoa', 'oats', 'bulgur', 'rice', 'pasta', 'bread']
amountOfUnits = [1, 2, 3, 4]
pricePerUnit = [0.50, 1.10, 1.40, 2.50, 3.10, 4.00, 5.20]

boughtProducts = (list(product(products, pricePerUnit)))

products_with_bought_date = []
for product in boughtProducts:
    bought_date = random.randint(1, 55) 
    # I want all data to stay in the range of 1 to 60.
    expiry_date = bought_date + 5 # 5 days after bought_date (to keep it simple for now)
    products_with_bought_date.append(product + (bought_date, expiry_date)) 
    # note to self: tuple concatenation, if needed use comma after expiry_date.

print(len(products_with_bought_date))

# now sort list with tuples on bought_date: (x[3] is the bought_date)
products_with_bought_date.sort(key=lambda x: x[3])
# note to self: sort is in-place, but sorted() returns a new list.
# print(products_with_bought_date) # status: ok (output: list with tuples)


# convert list with tuples into list with lists:
products_with_bought_date = [list(elem) for elem in products_with_bought_date]
# print(products_with_bought_date) # status: ok (output: list with lists)

# add id to each list in list:
for product_id, elem in enumerate(products_with_bought_date):
    elem.insert(0, product_id)
print(products_with_bought_date)
''' 
    problem: before I manually add a transaction to the testdata generated by this script, I must first manually check the last id, so I can add a new id that is 1 higher than the last id. But this id must be added as argparse argument. That is annoying / user unfriendly.
'''

# write list with lists to csv file:
path = os.getcwd()
print(path)
'''
    do not create file directly in  directory csv_files_used_by_superpy. Otherwise
    testdata will be overwritten and pytest testcases will  need to be updated to
    reflect the new testdata.
'''
path_to_bought_csv = path + '\\create_new_testdata_for_csv_files\\bought.csv'
with open(path_to_bought_csv, 'w', newline='') as csvfile:    
    writer = csv.writer(csvfile)
    writer.writerow(['id', 'product', 'price', 'bought_date', 'expiry_date'])
    writer.writerows(products_with_bought_date) # note to self: writerows() expects a list of lists.


print('---------ooo------------------------------------------')


# part 2 of 2: create testdata for sold.csv

products_with_sold_date = deepcopy(products_with_bought_date)
# not to self: I need immutable copy here.

print(products_with_sold_date)
print('---------ooo------------------------------------------')

# make following 2 adjustments:
for row in products_with_sold_date:
    # calculate price_sold: (price_sold = price_bought * 3)
    row[2] = row[2] * 3
    # set the sold_date to 2 days after bought_date:
    row[3] = row[3] + 2
print(products_with_sold_date)
'''
    no need to sort the list on column date_sold, becaus that was already done in part 1 (on date_bought) and
    date_sold = date_bought + 2. (so they correlate in a linear fashion)
'''

# delete each 5th list in list: (so each 5th row will expire while time traveling)
products_with_sold_date = [row for row in products_with_sold_date if row[0] % 5 != 0]   
'''
    row[0] refers to the automatically incrementing id of  each record in the csv file (starting at 0 to 79 inclusive).

    the ids in the sold.csv will jump from 4 to 6, 9 to 11, 14 to 16, etc. But that is ok, because
    each id is still unique.
'''


print('---------ooo------------------------------------------')
print(products_with_sold_date)

path = os.getcwd()
print(path)
'''
    do not create file directly in  directory csv_files_used_by_superpy. Otherwise
    testdata will be overwritten and pytest testcases will  need to be updated to
    reflect the new testdata.
'''
path_to_sold_csv = path + '\\create_new_testdata_for_csv_files\\sold.csv'
with open(path_to_sold_csv, 'w', newline='') as csvfile:
    writer = csv.writer(csvfile)
    writer.writerow(['id', 'product', 'price', 'sold_date', 'expiry_date'])
    writer.writerows(products_with_sold_date) # note to self: writerows() expects a list of lists.

